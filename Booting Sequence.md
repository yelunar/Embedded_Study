# Booting Sequence

![](https://user-images.githubusercontent.com/34755287/53879645-5a6b7b00-4052-11e9-84ad-25a4dc7c1306.png)

### **1. 컴퓨터가 처음에 켜지면?**

컴퓨터가 켜지자마자 메인보드에 내장된 부품인 **ROM**을 자동으로 읽어서 해야 할 일들을 하나씩 수행한다. 그래서 가장 먼저 ROM에 기본으로 설치되어 있는 **BIOS**를 읽어들인다. 

**BIOS**는 <u>운영 체제 중 가장 기본적인 소프트웨어이자 컴퓨터의 입출력을 처리하는 펌웨어</u>로 메인보드에 필수로 내장되어 있다.

- **펌웨어(펌 소프트웨어)**: 변경할 필요가 없는 소프트웨어를 **ROM에 내장**하여 <u>하드웨어를 제어하는 프로그램</u>

<img title="" src="https://blog.kakaocdn.net/dn/bDiUUy/btrqzQZGi40/SC4sW9ae5gKkFIevytcap0/img.png" alt="" width="392">*메인보드 제조사의 BIOS 초기 화면*

### **1.2. BIOS: POST, Boot Loader**

`BIOS`: Basic Input and Output System의 줄임말로 기본적인 입출력을 담당하는 기계어 루틴, 컴퓨터 하드웨어와 운영체제를 연결하는 역할을 함

**BIOS**는 부팅 과정 중 컴퓨터에 연결된 키보드, 램, 디스크 드라이브 등의 하드웨어가 올바로 작동하는지 각종 테스트나 초기화를 하는 **POST**(Power On Self Test)를 진행한다. 

BIOS는 **POST**를 성공적으로 마치면 <u>하드디스크에 저장된 운영체제를 메인 메모리에 적재</u>하는 **Boot Loader**를 실행시킨다. CPU가 곧바로 읽어들여야 하기 때문에 Boot Loader는 처음부터 Main Memory(DRAM)에 상주해있다. 

**부트 로더**를 잘못 건드리면 OS가 실행이 되지 않기 때문에 건드리지 못하게 Memory 안에서도 **ROM**(Read Only Memory)라는 영역에 할당되어 있다.

Boot Loader와 달리 **운영체제**는 하드디스크에 저장되어 있기 때문에 누군가가 **메모리로 로드**를 해줘야 한다. 그래서 초기에는 스토리지(HDD, SSD)에 OS 프로그램이 있다가 **Boot Loader**에 의해 하드디스크에 저장되어 있는 <u>OS(window or Linux)가 메인  메모리(RAM)에 올라가게 된다.</u> 이러한 부트로더의 과정을 `부팅` 이라고 한다. 

이제 **메모리**에 올라간 OS 프로그램을 **CPU**가 읽어들이면서 **OS를 실행**하고 부팅 과정을 마치게 된다.

- **부팅**: PC가 켜진 후에 **운영체제를 메인 메모리(DRAM)에 적재하는 일련의 과정**

즉, 부트로더의 역할은 !

- 임베디드 보드의 전원을 켰을 때, 플래시 메모리(ROM)에서 시작되는 시스템 소프트웨어로서 하드웨어를 초기화 시켜 주고, 커널을 메모리(RAM)에 적재(복사)시켜서 사용자 명령 처리를 준비하는 역할을 한다.

<img src="https://user-images.githubusercontent.com/34755287/53879648-5b041180-4052-11e9-9642-6bf80de33a3e.png" title="" alt="" width="424">

운영체제는 크게 **커널**(kernel)과 **명령어 해석기**(Command interpreter, shell)로 나뉜다.

- 커널은 말그대로 운영체제의 핵심으로 **운영체제가 수행하는 모든 것**이 저장되어있다. 

- 명령어 해석기는 사용자가 **커널(운영체제)에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력**한다.





### **1.3. 프로그램 실행 원리: CPU, 메모리**

<img src="https://blog.kakaocdn.net/dn/ccMr9D/btrqGqUiS1f/oPk9cywmcKbh7HpkkmKBg1/img.png" title="" alt="" width="544">

**CPU**는 <u>프로그램(명령어의 집합)을 메인 메모리(DRAM)에서만 가져와 처리</u>할 수 있기 때문에 프로그램을 실행하려면 반드시 프로그램이 메모리에 할당되어 있어야 한다. 

보조기억장치(HDD, SSD)에 있던 운영체제는 **ROM**에 있는 **부트 로더**가 <u>메모리에 적재</u>해주었지만, 다른 응용 프로그램(게임, 워드 등)들은 어떻게 메인 메모리에 적재할 수 있는 걸까?

바로 운영체제의 **커널**이 그 역할을 해준다. 

**커널**은 💡전원이 켜져 있는 동안에는 **메인 메모리에 계속 상주**하면서 시스템 자원을 관리한다. **커널**이 <u>응용 프로그램이나 데이터를 메인 메모리에 적재</u>하는 것을 로드(Load)라고 하며 그 과정을 로딩이라고 한다. 

프로그램이 메모리에 적재되면 비로소 **CPU**는 메모리에 있는 <u>프로그램 명령어들을 읽어와 실행</u>을 한다.







[컴퓨터 구조와 메모리 계층 구조(Memory hierarchy)](https://bentist.tistory.com/62)



---

✔️ ROM에 모든 메모리를 저장안하고 RAM을 쓰는 이유

ROM(Read-Only Memory)과 RAM(Random Access Memory)은 각각 다른 목적과 특성을 가지고 있다

왜 모든 메모리를 ROM에 저장하지 않고 RAM을 사용하는지에 대한 이유는 다음과 같다

1. **Read-Only vs. Read-Write**
   
   - ROM은 읽기 전용 메모리이기 때문에 데이터를 쓰기 위해 제한적
     
     즉, ROM에 저장된 데이터를 변경하거나 업데이트하기 어렵다. 
     - ROM이 읽기 전용으로 만들어진 이유
       
       1. 저장된 데이터의 무결성과 보존을 보장하기 위해
          
          중요한 데이터나 부트 로더와 같은 시스템의 핵심 부분을 안정적으로 보호
       
       2. ROM에 저장된 데이터는 외부에서 수정할 수 없으므로 데이터 보안을 강화할 수 있음
   - 반면 RAM은 읽고 쓰기 모두 가능하므로 프로그램 및 데이터를 자유롭게 수정하고 업데이트할 수 있다.

2. **프로그램 업데이트 및 유연성**
   
   - 시스템 및 소프트웨어 업데이트를 쉽게 적용할 수 있어야 합니다. ROM에 모든 것을 저장하면 새로운 프로그램 또는 데이터 업데이트를 반영하기가 어렵습니다. 반면 RAM을 사용하면 새로운 소프트웨어 버전을 쉽게 로드하고 업데이트할 수 있습니다.

3. **동적 데이터 저장**
   
   - 대부분의 프로그램은 실행 중에 동적으로 생성되는 데이터를 다루어야 합니다. 예를 들어, 사용자 입력, 중간 계산 결과, 네트워크 통신 데이터 등이 포함됩니다. 이러한 동적 데이터를 저장하려면 읽고 쓸 수 있는 RAM이 필요합니다.

4. **효율성 및 속도**
   
   - RAM은 빠른 읽기 및 쓰기 속도를 가지고 있어 데이터 및 프로그램을 효과적으로 처리할 수 있습니다. ROM은 읽기 속도가 빠르지만 쓰기가 제한적이며 속도가 느립니다.

5. **에너지 효율성**
   
   - RAM은 활성 상태에서만 데이터를 보유하고, 전원이 끊어지면 데이터가 손실됩니다. 이는 에너지를 절약하는 데 도움이 됩니다. 반면 ROM은 전원이 꺼져도 데이터가 보존됩니다.









---


