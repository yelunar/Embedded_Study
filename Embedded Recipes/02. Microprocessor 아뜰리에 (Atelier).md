# **02. Microprocessor 아뜰리에 (Atelier)**

![](https://blog.kakaocdn.net/dn/CjTus/btsg2jaOwXg/v4brX8Rb4hw6Z3kSbeI6e1/img.jpg)

- `Register Bank`: 32Bit 크기의 범용 Register 31개, Status Register 6개로 한대 묶여 있는 Register의 묶음, ARM core에서 **임시 저장공간을 담당**
  
- `Barrel Shifter`: Shift (왼쪽, 오른쪽), 또는 Rotation (오른쪽)을 실행할 32Bit WORD와 Shift 수를 입력 받아, Shift 수만큼 Shift한 32Bit결과를 출력하는 특별한 회로, 산술 연산을 시도할 때, 유용하게 사용 일종의 **Shift 가속기**
  
- Control Logic에 그려져 있는 개미 같은 in/output은 Control Logic이 **발생하는 control 신호와 동작을 하기 위한 Input**
  

<br>

## **ARM mode와 THUMB mode**

word: CPU가 한번에 처리할 수 있는 크기

✔️  ARM은 32bit RISC machine이고, 32bit로 동작 하는 게 최상의 Performance를 제공할 수 있다는 거

    ➡️ 32 bit ARM은 32가 word 단위이고 한번에 32bit씩 처리할 수 있다는 말

✔️ THUMB mode는 어찌 보면 ARM mode의 반쪽 version이라고 볼 수 있음

ARM core는동작 mode가 바뀌면 사용하는 Register set도 바뀜

**CPSR(Current Program Status Register)** 이라는 Register의 정체가 큰 역할, 아래처럼 생김

![](https://blog.kakaocdn.net/dn/dtj3Iq/btsgL83AJfr/iUTWK8MuCCvJkDVy0ZkWNk/img.jpg)

1. N : Negative : 연산결과가 마이너스인 경우에 set
2. Z : Zero : 연산결과가 0인 경우에 set
3. C : Carry : 연산결과에 자리 올림이 발생한 경우에 set
4. V : oVer flow : 연산의 결과가 overflow 났을 경우에 set되는데, Over flow라는건 넘치는 경우니까 원래 가져야 하는 Range보다 결과 값이 큰 경우가 그 경우에 해당

✔️ ARM core는 Opcode를 Memory에서 가져오자 마자 (Fetch) 이를 무조건 실행하는 것이 아니라 <u>condition flag인 NZCV를 보고 바로 앞 opcode의 실행결과를 보고 실행할지 말지를 결정할 수 있음</u>

CPSR의 값은 현재의 mode도 확인 가능한 register

CPSR의 하위 5bit를 원하는 mode로 setting하면 그 mode로 전환

<mark>System mode와 User mode는 이 CPSR의 mode bit만 차이가 나고 나머지 Register는 모두</mark> <mark>같이 사용</mark>

✔️ `SPSR(Saved Program Status Register)` 말 그대로 CPSR을 복사해 넣는 특수 Register, CPSR을 backup씀

➡️ 언제 backup하느냐? SPSR에 CPSR의 값을 backup해 놓고 mode를 바꾸게 되었을 때, SPSR의 값을 CPSR에 다시 집어 넣으면 이전 mode로 곧바로 복귀할 수 있음

`R14 (Linked Register)`: ARM은 어딘가로 branch (jump)를 할 때 어디서 branch 해 왔는지를 표시

`R13 (Stack Pointer)`: 현재 Stack을 어디까지 쌓아 두었는지 가리킴

`R15 (Program counter)`: 이 녀석은 현재 어디를 수행하고 있는 건지를 나타냄. **실행하는 위치가 아니라 Fetch해온 위치를 가리키는 것**

나머지 R0~R12까지는 CPU의 동작중의 저장용도로 적절히 사용

`Context`: MCU의 현재 상황, Context Switching이라는 건 상황을 바꿔 침.

<br>

## **ARM 동작 Modes**

![](https://blog.kakaocdn.net/dn/RBdYI/btsgTiEo5yW/XU0Uzi51dMFr05rNKNndQk/img.jpg)![](https://blog.kakaocdn.net/dn/bl4vL3/btsgQq3Rcbb/v3ebzVyk97NEYkdjWr6T4k/img.jpg)

- Privileged Mode (특권 모드)는 IRQ나 FIQ등의 Interrupt의 사용 가능 유무를 직접 설정 할 수 있음
  
- Privileged Mode는 자기들끼리, 자기네들 스스로 서로 Mode 변경이 자유자재로 가능 합니다만, Normal Mode는 자기 스스로 Privileged Mode로 Mode의 변경이 불가능
  
  - **SYS ↔ FIQ, IRQ ↔ SVC과 같이 Privileged Mode → Normal Mode (USR)은 가능하지만, USR → Privileged Mode로의 변경은 불가능**

---

## **ARM/ Thumb PCS - 레지스터 사용법**

 APCS(ARM Procedure Call Standard): 특수용법의 Register이외의 일반 Register들도 쓰이는 쓰임새

![](https://blog.kakaocdn.net/dn/xVFTv/btsgTjwGafp/kiDX8rNKSlShL7ZDfgxjE1/img.jpg)

##### **Synonym**

Synonym은 R0~R11까지의 Register들을 다른 이름으로 부를 수도 있다는 걸 의미

Special이라고 쓰여진 부분은 죄수번호 부르듯이 번호로 부르는 것 이외에, 더욱 Special한 기능을 한다고 하여, 이름을 또 하나 붙인 셈이
이중에 가장 많이 사용하는 건, **<mark>R0(a1), R1(a2), R2(a3), R3(a4), SP, LR, PC</mark>** 요 녀석들은 꼭 알아 둬야함!

##### **R0~R3 (a1~a4) Descriptions (Argument/ Result/ Scratch)**

**1) Argument**

일단은 R0~R3 까지는 함수에서 Argument를 넘길 때 사용 
예를 들어,

int **function** (int a, int b, int c, int d)  
라는 함수가 있다고 했을 때, 이 함수를 실제로 사용할 때는  
(void)function ( 10, 20, 30, 40); 이런 식으로 사용하겠죠?

이럴 때 기본적으로 R0 := 10, R1 := 20, R2 := 30, R3 := 40 요런 식으로 Register를 사용

또한 이 함수의 원형이 Integer return type이므로, 이 함수의 결과 값이 100이라고 한다면, 함수의 return 값을 R0에 넣는 게 상례

f =  function (10, 20, 30, 40);  함수 호출 시에는 R0 := 10, R1 := 20, R2 := 30, R3 := 40 이고요, 함수 return시에는 R0 : = 100, 결국 f = 100.

➡️ **불리자 마자의 R0 ~ R3값은 Argument**, **돌아올 때 R0의 값이 return값**

**2) Result (Return Value)**

R0~R3에 pointer값을 전달하게 되면, 실제 주소 값을 전달하여, 호출 되는 쪽 함수에서 장난을 치겠죠. 그럴 때, 돌아오는 순간에 그 주소 값을 그대로 다시 R1~R3에 넣어주면 다시 호출한 쪽에서 return값처럼 R1~R3를 그대로 가져다 쓰면 되겠죠. 부른 입장에서는 R1~R3의 값이 바꾸지 않는 것이라고 보면 됨

또는 Register 1개는 32bit 즉 4byte이니까, return값이 4byte보다 큰 녀석을 return할 때는 다른 Register들도 사용해야겠죠. 그러니까 **최대 4byte * 4개 = 16byte까지 한번에 return**

그럼 4개 초과의 argument를 전달하면 stack에 push

**3) Scratch (연습장)**

어떤 함수가 불리면서 argument의 전달 수단으로 R0~R3이 쓰이고 나면, 불려진 함수 내부에서는 돌아갈 때 APCS의 약속만 잘 지켜주면, 불려진 함수 내에서는 그 Register들을 CPU가 마치 연습장처럼 임시저장 용도로 마구 사용 가능 즉, 다른 용도로 쓸 수 있다는 뜻

![](https://blog.kakaocdn.net/dn/bhk4EP/btsgUsNXPaN/e2OjhwbPLS1hIpxKUnMV8K/img.jpg)

**R4~R11 (v1~v8)**

R4~R11은 variable 용으로서, <u>함수 호출 후에 바뀌어서는 안 되는 값</u>들로서, 호출당한 함수는 R4~R11을 사용하려면, stack에 저장 후에 사용하고, 호출당한 함수가 끝나기 전에 복원

**R12~R15 (특수 Register들)**

`R12 (IP, Intra..)` : ARM-Thumb interworking등에 또는 long branch시에 Veneer를 통해  주소 할당 시에 임시 보관소로 사용함
`R13 (SP, Stack Pointer)`: Stack을 사용하기 위해 Stack Pointer로 사용 
`R14 (LR, Link Register)`: 함수를 호출하거나, 어디론가 jump했을 때 돌아올 주소를 넣는 목적
`R15 (PC, Program Counter)`: 현재 실행하고 있는 주소. (Pipe line을 고려하면 Fetch하고 있는 주소)  
**이런 규칙을 따르려면 어떻게 할까?**

➡️ Compiler Option을 -apcs라고 주면 compiler가 이런 AAPCS 규칙에 따라 Compile을 해줌 

✔️ R13 (SP), R14 (LR)도 General Register로 사용할 수 있지만 R13과 R14의 경우에 General Register로 쓰면 좀 위함

➡️ 보통, R13의 경우 ARM을 기반으로 하여 ARM을 지원하는 OS들은 R13이 항상 유효한 Stack Pointer임을 가정하고 구현 또한 함수 호출에 관련해서도 R14는 유효한 Linked Register 값이 들어 있음을 compiler가 가정하기 때문에 그럼

<br>

## **ARM은 Interrupt가 걸리면 어떻게 행동할까**

![](https://blog.kakaocdn.net/dn/bcM1AA/btsgKpdcL4s/h6xVcsWPhUEiSYntbkCgn0/img.jpg)

MCU안에는 Interrupt Controller라는 IP가 하나 달려 있고, 외부에 나와 있는 pin이나, 내부에 있는 IP와 Interrupt Controller사이에 전깃줄이 하나 달려 있어서, 그 선을 통해서 신호를 주면 Interrupt Controller가 Interrupt가 들어 왔구나 하면서, CPU의 mode를 IRQ mode로 바꿔 줌
